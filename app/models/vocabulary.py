"""
Game Vocabulary System
======================
The single source of truth for game system definitions.

This module defines the "building blocks" of any TTRPG system.
"""

from enum import Enum
from functools import cached_property
from typing import Any, Dict, List, Optional, Union
import re
import logging

from pydantic import BaseModel, Field

logger = logging.getLogger(__name__)


# =============================================================================
# ENUMS: The Two Dimensions
# =============================================================================


class FieldType(str, Enum):
    NUMBER = "number"  # Simple integer or float
    POOL = "pool"  # Current/Max pair
    TRACK = "track"  # Checkbox array
    DIE = "die"  # Die notation string
    LADDER = "ladder"  # Named rating
    TAG = "tag"  # Narrative tag
    TEXT = "text"  # Free-form text
    LIST = "list"  # Array of items


class SemanticRole(str, Enum):
    CORE_TRAIT = "core_trait"  # attributes
    RESOURCE = "resource"  # resources
    CAPABILITY = "capability"  # skills
    STATUS = "status"  # features
    ASPECT = "aspect"  # narrative
    PROGRESSION = "progression"  # progression
    EQUIPMENT = "equipment"  # inventory
    CONNECTION = "connection"  # connections
    # META = "meta"  # meta


# =============================================================================
# CONSTANTS: Path Mapping
# =============================================================================

# Maps semantic roles to the actual storage category in the Entity JSON.
# This ensures that paths generated by the Vocabulary (e.g. for Invariants)
# match the actual structure of the data in the database.
ROLE_TO_CATEGORY = {
    SemanticRole.CORE_TRAIT: "attributes",
    SemanticRole.RESOURCE: "resources",
    SemanticRole.CAPABILITY: "skills",
    SemanticRole.STATUS: "features",
    SemanticRole.ASPECT: "narrative",
    SemanticRole.PROGRESSION: "progression",
    SemanticRole.EQUIPMENT: "inventory",
    SemanticRole.CONNECTION: "connections",
    # SemanticRole.META: "meta",
}

CATEGORY_TO_ROLE = {v: k for k, v in ROLE_TO_CATEGORY.items()}


# =============================================================================
# FIELD DEFINITION
# =============================================================================


class FieldDefinition(BaseModel):
    key: str = Field(
        ..., description="Unique snake_case identifier within its role category"
    )
    label: str = Field(..., description="Human-readable display name")
    description: str = Field("", description="Explanation for prompts and UI tooltips")

    semantic_role: SemanticRole = Field(..., description="What this field represents")
    field_type: FieldType = Field(..., description="How the data is stored")

    # Type-Specific Configuration
    default_value: Optional[Any] = None
    min_value: Optional[Union[int, float]] = None
    max_value: Optional[Union[int, float]] = None
    max_source: Optional[str] = None
    track_length: Optional[int] = None
    die_default: Optional[str] = None
    ladder_labels: Optional[Dict[int, str]] = None

    # Derived / Meta
    formula: Optional[str] = None
    is_derived: bool = False
    governing_trait: Optional[str] = None
    requires_training: bool = False

    # Validation / Display
    can_go_negative: bool = False
    clamp_to_max: bool = True
    icon: Optional[str] = None
    color: Optional[str] = None
    hidden: bool = False

    def get_sub_paths(self) -> List[str]:
        """Returns valid sub-paths based on field type."""
        if self.field_type == FieldType.POOL:
            return ["current", "max"]
        elif self.field_type == FieldType.TRACK:
            length = self.track_length or 4
            return [str(i) for i in range(length)] + ["filled"]
        elif self.field_type == FieldType.LADDER:
            return ["value", "label"]
        elif self.field_type == FieldType.TAG:
            return ["text", "free_invokes"]
        else:
            return []


# =============================================================================
# GAME VOCABULARY
# =============================================================================


class GameVocabulary(BaseModel):
    system_name: str
    system_id: str = ""
    genre: str = "fantasy"
    version: str = "1.0"

    dice_notation: str = "d20"
    resolution_mechanic: str = ""

    fields: Dict[str, FieldDefinition] = Field(default_factory=dict)
    terminology: Dict[str, str] = Field(default_factory=dict)

    def add_field(self, field: FieldDefinition) -> None:
        full_key = f"{field.semantic_role.value}.{field.key}"
        self.fields[full_key] = field
        # Clear cached properties
        self.__dict__.pop("valid_paths", None)
        self.__dict__.pop("valid_path_patterns", None)

    @cached_property
    def valid_paths(self) -> List[str]:
        """
        All valid dot-paths for entity data, using canonical storage categories.
        E.g. returns 'resources.hp.current' instead of 'resource.hp.current'.
        """
        paths = []

        for full_key, field in self.fields.items():
            # full_key is stored as "role.key" (e.g. resource.hp)
            role_str, key = full_key.split(".", 1)

            # Convert Role -> Canonical Category
            # e.g. "resource" -> "resources"
            try:
                role = SemanticRole(role_str)
                category = ROLE_TO_CATEGORY.get(role, role.value)
            except ValueError:
                category = role_str

            base_path = f"{category}.{key}"

            # Add sub-paths based on field type
            sub_paths = field.get_sub_paths()
            if sub_paths:
                for sub in sub_paths:
                    paths.append(f"{base_path}.{sub}")
            else:
                paths.append(base_path)

        # Standard Identity paths
        paths.extend(
            [
                "identity.name",
                "identity.description",
                "identity.concept",
                "identity.player_name",
            ]
        )

        return sorted(set(paths))

    @cached_property
    def valid_path_patterns(self) -> List[str]:
        """
        Regex patterns for wildcard matching, using canonical categories.
        E.g. 'attributes.*'
        """
        patterns = set()

        # Determine which categories have fields
        active_categories = set()
        for full_key in self.fields.keys():
            role_str = full_key.split(".")[0]
            try:
                role = SemanticRole(role_str)
                cat = ROLE_TO_CATEGORY.get(role, role_str)
                active_categories.add(cat)
            except ValueError:
                continue

        for cat in active_categories:
            patterns.add(rf"{cat}\.[a-z_][a-z0-9_]*")
            patterns.add(rf"{cat}\.[a-z_][a-z0-9_]*\.[a-z_][a-z0-9_]*")

        return list(patterns)

    def validate_path(self, path: str) -> bool:
        path = path.strip().lower()
        if path in self.valid_paths:
            return True

        if "*" in path:
            regex_pattern = path.replace(".", r"\.").replace("*", r"[a-z_][a-z0-9_]*")
            try:
                pattern = re.compile(f"^{regex_pattern}$")
                return any(pattern.match(p) for p in self.valid_paths)
            except re.error:
                return False

        for pattern in self.valid_path_patterns:
            try:
                if re.match(f"^{pattern}$", path):
                    return True
            except re.error:
                continue
        return False

    def expand_wildcard_path(self, path: str) -> List[str]:
        if "*" not in path:
            return [path] if self.validate_path(path) else []

        regex_pattern = path.replace(".", r"\.").replace("*", r"[a-z_][a-z0-9_]*")
        try:
            pattern = re.compile(f"^{regex_pattern}$")
            return [p for p in self.valid_paths if pattern.match(p)]
        except re.error:
            return []

    # === Query Methods ===

    def get_fields_by_role(self, role: SemanticRole) -> Dict[str, FieldDefinition]:
        prefix = f"{role.value}."
        return {
            k.replace(prefix, ""): v
            for k, v in self.fields.items()
            if k.startswith(prefix)
        }

    def get_field_by_path(self, path: str) -> Optional[FieldDefinition]:
        """
        Get field definition from a canonical path (e.g. 'resources.hp.current').
        """
        parts = path.split(".")
        if len(parts) < 2:
            return None

        category, key = parts[0], parts[1]

        # Convert Canonical Category -> Role
        # e.g. "resources" -> "resource"
        role = CATEGORY_TO_ROLE.get(category)
        if not role:
            # Fallback: maybe the path used the role name directly?
            try:
                role = SemanticRole(category)
            except ValueError:
                return None

        full_key = f"{role.value}.{key}"
        return self.fields.get(full_key)

    # === Prompt Generation ===

    def get_path_hints_for_prompt(self, include_descriptions: bool = False) -> str:
        lines = ["## Valid Entity Paths for This System\n"]

        # Iterate by Role, but display Category
        for role in SemanticRole:
            role_fields = self.get_fields_by_role(role)
            if not role_fields:
                continue

            category = ROLE_TO_CATEGORY.get(role, role.value)
            lines.append(f"**{category.replace('_', ' ').title()} ({role.value}):**")

            for key, field in role_fields.items():
                base_path = f"{category}.{key}"
                sub_paths = field.get_sub_paths()

                if sub_paths:
                    sub_str = ", ".join(f".{s}" for s in sub_paths[:3])
                    if len(sub_paths) > 3:
                        sub_str += ", ..."
                    path_display = f"`{base_path}` ({sub_str})"
                else:
                    path_display = f"`{base_path}`"

                if include_descriptions and field.description:
                    lines.append(f"  - {path_display}: {field.description}")
                else:
                    lines.append(f"  - {path_display}")

            lines.append("")

        return "\n".join(lines)

    def get_field_hints_for_prompt(self, role: Optional[SemanticRole] = None) -> str:
        # (This method remains largely the same, just rendering logic)
        lines = []
        fields_to_describe = (
            self.get_fields_by_role(role)
            if role
            else {k: v for k, v in self.fields.items()}
        )

        for full_key, field in fields_to_describe.items():
            # Note: We display the canonical key here for consistency
            role_part, key_part = full_key.split(".", 1)
            try:
                r = SemanticRole(role_part)
                cat = ROLE_TO_CATEGORY.get(r, role_part)
            except Exception as e:
                logger.warning(f"Unknown semantic role '{role_part}': {e}")
                cat = role_part

            canonical_key = f"{cat}.{key_part}"

            type_hint = self._get_type_hint(field)
            range_hint = self._get_range_hint(field)

            parts = [f"- **{field.label}** (`{canonical_key}`)"]
            parts.append(f"  Type: {type_hint}")
            if range_hint:
                parts.append(f"  Range: {range_hint}")
            if field.description:
                parts.append(f"  Info: {field.description}")

            lines.append("\n".join(parts))

        return "\n\n".join(lines)

    def _get_type_hint(self, field: FieldDefinition) -> str:
        type_hints = {
            FieldType.NUMBER: "integer value",
            FieldType.POOL: "pool with current/max",
            FieldType.TRACK: f"track with {field.track_length or 4} boxes",
            FieldType.DIE: f"die type (e.g., {field.die_default or 'd8'})",
            FieldType.LADDER: "rating on a ladder",
            FieldType.TAG: "narrative tag/aspect",
            FieldType.TEXT: "free-form text",
            FieldType.LIST: "list of items",
        }
        return type_hints.get(field.field_type, "value")

    def _get_range_hint(self, field: FieldDefinition) -> str:
        parts = []
        if field.min_value is not None:
            parts.append(f"min {field.min_value}")
        if field.max_value is not None:
            parts.append(f"max {field.max_value}")
        if field.ladder_labels:
            labels = [f"{v}={k}" for k, v in sorted(field.ladder_labels.items())]
            parts.append(f"labels: {', '.join(labels[:4])}")
        return ", ".join(parts) if parts else ""

    def to_summary_dict(self) -> Dict[str, Any]:
        return {
            "system_name": self.system_name,
            "total_fields": len(self.fields),
            "dice": self.dice_notation,
        }
